---
story_id: "5.3"
title: "Movimenti Magazzino"
status: "draft"
priority: "high"
estimate: "M"
---

# Story 5.3: Movimenti Magazzino

## Story

As a Tecnico, I want to record stock movements, so that inventory quantities are accurate.

## Acceptance Criteria

### AC-1 - Movimento CARICO con tracciamento utente e timestamp
**Given** articolo `id=5` ha `giacenza=10`.
**When** un utente autenticato con ruolo `TECNICO` invoca `POST /api/articoli/5/movimenti` con `{ tipo: "CARICO", quantita: 20, riferimento: "Ordine FOR-000001" }`.
**Then** la giacenza diventa `30`, il movimento viene registrato con `userId` e timestamp, e la risposta e `201`.

### AC-2 - Movimento SCARICO con decremento giacenza
**Given** articolo `id=5` ha `giacenza=30`.
**When** un utente autenticato con ruolo `TECNICO` invoca `POST /api/articoli/5/movimenti` con `{ tipo: "SCARICO", quantita: 15, riferimento: "Riparazione RIP-20260209-0001" }`.
**Then** la giacenza diventa `15`, viene registrato un movimento con `userId` del tecnico e timestamp, e la risposta e `201`.

### AC-3 - Blocco scarico oltre disponibilita
**Given** articolo `id=5` ha `giacenza=5`.
**When** un utente autenticato con ruolo `TECNICO` invoca `POST /api/articoli/5/movimenti` con `{ tipo: "SCARICO", quantita: 10 }`.
**Then** la risposta e `400` con errore `"Insufficient stock: available 5, requested 10"`.

### AC-4 - Movimento RETTIFICA con quantita negativa
**Given** articolo `id=5` ha `giacenza=15`.
**When** un utente autenticato con ruolo `TECNICO` invoca `POST /api/articoli/5/movimenti` con `{ tipo: "RETTIFICA", quantita: -5, riferimento: "Inventario fisico" }`.
**Then** la giacenza diventa `10`, viene registrato un movimento con `tipo=RETTIFICA`, `userId` e timestamp, e la risposta e `201`.

### AC-5 - Gestione concorrente SCARICO in transazione atomica
**Given** articolo `id=5` ha `giacenza=10` e due richieste concorrenti inviano `POST /api/articoli/5/movimenti` con payload `{ tipo: "SCARICO", quantita: 7, riferimento: "Riparazione RIP-20260209-0002" }`.
**When** le due richieste arrivano in parallelo (es. `Promise.all` lato test) e tentano entrambe il decremento.
**Then** una sola richiesta riceve `201`, l'altra riceve `400 "Insufficient stock"`, e la giacenza finale resta `3`.

## Task Breakdown

- [x] Route backend: estendere `packages/backend/src/routes/articoli.ts` con endpoint `POST /api/articoli/:articoloId/movimenti`, middleware `authenticate` + `authorize("TECNICO", "ADMIN")`, parsing payload e mapping errori sul failure responder esistente.
- [x] Service backend: implementare in `packages/backend/src/services/anagrafiche-service.ts` parser/input validation per `tipo`, `quantita`, `riferimento` e funzione applicativa con transazione atomica per aggiornamento giacenza + registrazione movimento con `userId` e timestamp.
- [x] ATDD backend: creare `packages/backend/src/__tests__/articoli-movimenti-atdd.spec.ts` con casi AC-1..AC-5 e verifiche esplicite su status `201/400`, messaggi errore e giacenza finale.
- [x] Concurrency ATDD: in `packages/backend/src/__tests__/articoli-movimenti-atdd.spec.ts` aggiungere scenario con due chiamate parallele `SCARICO` (`Promise.all`) e assert che solo una richiesta passi, con giacenza finale coerente con una sola sottrazione.

## Dependencies

- Story 5.1 completata (modello articolo e creazione base).
- Story 5.2 completata (router articoli e letture inventario gia disponibili).

## Notes for Implementation

- Riutilizzare il pattern ok/failure union gia presente in `packages/backend/src/services/anagrafiche-service.ts`.
- Mantenere il contratto errori coerente con le route articoli attuali (`error.code`, `error.message`).
