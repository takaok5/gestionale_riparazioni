---
status: ready-for-dev
priority: high
estimate: M
story_id: "1.2"
epic: "Epic 1 - Autenticazione e Gestione Sessione"
---

# Story 1.2: Rinnovo Sessione con Refresh Token

**As a** Tecnico, **I want** rinnovare la sessione usando un refresh token valido, **so that** posso continuare a usare l'app senza rifare il login ogni 15 minuti.

## Acceptance Criteria

### AC-1
**Given** esiste un utente attivo `mario.rossi` con password `Password1` e ho ottenuto un `refreshToken` eseguendo `POST /api/auth/login` con quelle credenziali  
**When** invio `POST /api/auth/refresh` con body JSON `{ "refreshToken": "<refreshToken_valido>" }`  
**Then** ricevo `200` con body contenente `accessToken` stringa, `refreshToken` stringa e `user` `{ id: 1, username: "mario.rossi", email: "mario.rossi@example.com", role: "TECNICO" }`

### AC-2
**Given** invio `POST /api/auth/refresh` con body JSON `{}` senza campo `refreshToken`  
**When** la richiesta raggiunge l'endpoint refresh  
**Then** ricevo `401` con `error.code = "INVALID_REFRESH_TOKEN"` e la risposta non contiene i campi `accessToken` e `refreshToken`

### AC-3
**Given** invio `POST /api/auth/refresh` con body JSON `{ "refreshToken": "abc" }` dove il token non e' in formato JWT  
**When** la richiesta viene validata dal servizio di autenticazione  
**Then** ricevo `401` con `error.code = "INVALID_REFRESH_TOKEN"` e la risposta non contiene i campi `accessToken` e `refreshToken`

### AC-4
**Given** invio `POST /api/auth/refresh` con un JWT refresh scaduto oppure firmato con secret diverso da `JWT_SECRET`  
**When** il token viene verificato in backend  
**Then** ricevo `401` con `error.code = "INVALID_REFRESH_TOKEN"` e la risposta non contiene i campi `accessToken` e `refreshToken`

### AC-5
**Given** invio `POST /api/auth/refresh` con un refresh token valido associato all'utente `mario.disabilitato` con `isActive=false`  
**When** il backend risolve l'utente dal token e verifica lo stato account  
**Then** ricevo `401` con `error.code = "ACCOUNT_DISABLED"` e la risposta non contiene i campi `accessToken` e `refreshToken`

## Target Modules

- `packages/backend/src/routes/auth.ts`
- `packages/backend/src/services/auth-service.ts`
- `packages/backend/src/middleware/auth.ts`
- `packages/backend/src/lib/errors.ts`
- `packages/shared/src/types/index.ts`
- `packages/backend/src/__tests__/auth-refresh.spec.ts`

## Task Breakdown

- [x] Task 1 (AC-1, AC-2, AC-3, AC-4, AC-5): aggiungere in `packages/backend/src/routes/auth.ts` l'endpoint `POST /api/auth/refresh` con parsing body `{ "refreshToken": string }`, chiamata al service e mapping errori su `buildErrorResponse`.
- [x] Task 2 (AC-1, AC-2, AC-3, AC-4): estendere `packages/backend/src/services/auth-service.ts` con funzione `refreshSession(...)` che valida presenza/formato token, verifica JWT, e re-emette coppia token con `issueAuthTokens`.
- [x] Task 3 (AC-5): in `packages/backend/src/services/auth-service.ts` verificare `isActive` sull'utente risolto dal payload JWT prima di emettere nuovi token.
- [x] Task 4 (AC-1, AC-2, AC-3, AC-4, AC-5): aggiungere `packages/backend/src/__tests__/auth-refresh.spec.ts` con test API per successo refresh, token mancante, token non JWT, token scaduto/firma invalida e account disabilitato.
- [x] Task 5 (AC-1): aggiornare `packages/shared/src/types/index.ts` con un tipo esportato riusabile per la risposta refresh (allineato alla shape login `{ accessToken, refreshToken, user }`).
- [x] Task 6 (AC-2, AC-3, AC-4, AC-5): verificare in `packages/backend/src/lib/errors.ts` e nei test che i casi `401` non espongano mai campi token in risposta.
