---
status: drafted
priority: high
estimate: M
story_id: "4.4"
title: "Approvazione/Rifiuto Preventivo"
---

# Story 4.4: Approvazione/Rifiuto Preventivo

## User Story
Come Commerciale voglio registrare l'approvazione o il rifiuto del preventivo cosi' che il flusso della riparazione prosegua correttamente.

## Acceptance Criteria (Expanded)

### AC-1
**Given** esiste il preventivo `id=5` con `stato="INVIATO"`, associato alla riparazione `id=10` con `stato="IN_ATTESA_APPROVAZIONE"`.
**When** invio `PATCH /api/preventivi/5/risposta` con payload `{ "approvato": true }` autenticato come Commerciale.
**Then** ricevo HTTP `200`, la risposta include `data.id=5`, `data.stato="APPROVATO"` e `data.riparazioneStato="APPROVATA"`, il preventivo `id=5` viene aggiornato a `stato="APPROVATO"`, `dataRisposta` e' valorizzato con timestamp ISO non nullo, e la riparazione `id=10` viene aggiornata a `stato="APPROVATA"`.

### AC-2
**Given** esiste il preventivo `id=5` con `stato="INVIATO"`, associato alla riparazione `id=10` con `stato="IN_ATTESA_APPROVAZIONE"`.
**When** invio `PATCH /api/preventivi/5/risposta` con payload `{ "approvato": false }` autenticato come Commerciale.
**Then** ricevo HTTP `200`, la risposta include `data.id=5`, `data.stato="RIFIUTATO"` e `data.riparazioneStato="ANNULLATA"`, il preventivo `id=5` viene aggiornato a `stato="RIFIUTATO"`, `dataRisposta` e' valorizzato con timestamp ISO non nullo, e la riparazione `id=10` viene aggiornata a `stato="ANNULLATA"`.

### AC-3
**Given** esiste il preventivo `id=5` con `stato="BOZZA"`.
**When** invio `PATCH /api/preventivi/5/risposta` con payload `{ "approvato": true }` oppure `{ "approvato": false }`.
**Then** ricevo HTTP `400` con errore esatto `"Preventivo must be in INVIATO state to record response"`, il preventivo resta `stato="BOZZA"` con `dataRisposta=null`, e la riparazione collegata non cambia stato.

### AC-4
**Given** esiste il preventivo `id=5` con `stato="APPROVATO"` e `dataRisposta` gia' valorizzato.
**When** invio `PATCH /api/preventivi/5/risposta` con payload `{ "approvato": true }` oppure `{ "approvato": false }`.
**Then** ricevo HTTP `400` con errore esatto `"Response already recorded for this preventivo"`, `dataRisposta` resta invariato e la riparazione collegata non cambia stato.

## AC Source Mapping
- AC-1: Derived from epic-details AC-1 (docs/epics/epic-4-preventivi-fatturazione.md:58)
- AC-2: Derived from epic-details AC-2 (docs/epics/epic-4-preventivi-fatturazione.md:59)
- AC-3: Derived from epic-details AC-3 (docs/epics/epic-4-preventivi-fatturazione.md:60)
- AC-4: Derived from epic-details AC-4 (docs/epics/epic-4-preventivi-fatturazione.md:61)

## Task Breakdown
- [x] Estendere `packages/backend/src/routes/preventivi.ts` con endpoint `PATCH /:id/risposta`, parsing payload `{ approvato: boolean }`, autorizzazione ruolo commerciale e mapping errori HTTP 400/404/500 secondo convenzioni route esistenti (copertura AC-1, AC-2, AC-3, AC-4).
- [x] Estendere `packages/backend/src/services/preventivi-service.ts` con use case `registraRispostaPreventivo` su percorso Prisma: controllo stato iniziale `INVIATO`, blocco doppia risposta, aggiornamento `stato`/`dataRisposta` e transizione riparazione (`APPROVATA` o `ANNULLATA`) in transazione atomica (copertura AC-1, AC-2, AC-3, AC-4).
- [x] Allineare percorso test-store in `packages/backend/src/services/preventivi-service.ts` con la stessa logica del percorso Prisma per mantenere parita' comportamentale in test ATDD (copertura AC-1, AC-2, AC-3, AC-4).
- [ ] Aggiornare `packages/backend/prisma/schema.prisma` con campo `dataRisposta` sul modello preventivo e creare migration Prisma coerente per ambienti reali (copertura AC-1, AC-2, AC-4).
- [x] Aggiungere test ATDD dedicati in `packages/backend/src/__tests__/preventivi-response-atdd.spec.ts` per i 4 scenari AC con assert su HTTP status, messaggi errore, stato preventivo, `dataRisposta`, stato riparazione e invarianti di non-mutazione nei casi 400 (copertura AC-1, AC-2, AC-3, AC-4).
- [x] Estendere helper test in `packages/backend/src/services/preventivi-service.ts` per impostare/leggere stato riparazione e `dataRisposta` nei fixture, cosi' da verificare in modo deterministico gli scenari "already recorded" e "invalid initial state" (copertura AC-3, AC-4).

## Note Tecniche
- Riutilizzare pattern route e `respond*Failure` gia' presenti in `packages/backend/src/routes/preventivi.ts`.
- Evitare divergenze tra implementazione Prisma e test-store.
- Mantenere messaggi di errore esatti per evitare regressioni ATDD.

## Blocker
- Migration Prisma non generata in questa esecuzione: nel repository non e' presente una directory `packages/backend/prisma/migrations` e la pipeline locale non ha eseguito `prisma migrate dev`. Lo schema e il client Prisma sono comunque allineati (`db:generate` eseguito).

## Validazione Step 4 - Issue e Fix Applicati

1. Problema: AC-1/AC-2 non esplicitavano i campi minimi del body di risposta da verificare, lasciando ambiguita' su cosa asserire lato test.
   Fix: aggiunti assert espliciti su `data.id`, `data.stato` e `data.riparazioneStato` in AC-1 e AC-2.
2. Problema: AC-3 copriva solo il payload `{ approvato: true }`, lasciando non definito il comportamento con `{ approvato: false }` quando lo stato iniziale non e' `INVIATO`.
   Fix: AC-3 ora richiede esplicitamente che entrambi i payload producano HTTP 400 e nessuna mutazione di preventivo/riparazione.
3. Problema: AC-4 non esplicitava il vincolo di non mutazione dopo risposta gia' registrata.
   Fix: AC-4 ora richiede `dataRisposta` invariato e stato riparazione invariato, con payload sia `true` sia `false`.
